# ============================================================================
# Q-Learning Tabular Update - Lookup Table with Constrained Updates
# ============================================================================
#
# This spec demonstrates how Tau can enforce update rules on a lookup table.
# It models a single Q-learning update step on a tiny 2x2 Q-table.
#
# ============================================================================
# HOW TO READ TAU SYNTAX
# ============================================================================
#
# STREAM DECLARATIONS:
#   i1 : bv[8] := in console   -- input stream, 8-bit bitvector, from console
#   o1 : bv[8] := out console  -- output stream, 8-bit bitvector, to console
#
# TYPE ANNOTATIONS:
#   o1[t]:bv[8]            -- output at time t, typed as bv[8]
#
# HELPER FUNCTIONS:
#   fname(x) : bv[8] := expr   -- define function returning bv[8]
#
# KEY OPERATORS:
#   +   addition           x + y (modular, wraps at 256)
#   &   bitwise AND        x & y
#   |   bitwise OR         x | y
#   ^   bitwise XOR        x ^ y
#   *   multiplication     x * y (modular)
#
# ============================================================================
# MENTAL MODEL
# ============================================================================
# A Q-table maps (state, action) pairs to scores:
#   Q : S x A -> R
#
# For a 2-state, 2-action system, the table has 4 entries:
#   Q00 = Q(state=0, action=0)
#   Q01 = Q(state=0, action=1)
#   Q10 = Q(state=1, action=0)
#   Q11 = Q(state=1, action=1)
#
# THE Q-LEARNING UPDATE
# ---------------------
# Classic Q-learning:
#   Q(s,a) <- (1-alpha)*Q(s,a) + alpha*(r + gamma*max_a' Q(s',a'))
#
# Simplified version (for integer arithmetic):
#   target = r + q_next
#   if learn=1: Q(s,a) <- target
#   if learn=0: no change
#
# WHAT TAU ENFORCES (the "guardrails" pattern)
# --------------------------------------------
# - Exactly one entry is updated (the one selected by s,a)
# - All other entries are unchanged
# - The update uses the correct formula
#
# The host system chooses WHAT to update; Tau enforces HOW.
#
# DESIGN: SINGLE-STEP SPEC
# ------------------------
# This spec models ONE update step. The current table is INPUT, the updated
# table is OUTPUT. To run multi-step learning, the host must "close the loop"
# by feeding the output table back as the next step's input.
#
# ============================================================================

set charvar off

# ----------------------------------------------------------------------------
# STREAM DECLARATIONS (syntax: name : type := in/out source)
# ----------------------------------------------------------------------------
# Control inputs
i1 : bv[8] := in console
i2 : bv[8] := in console
i3 : bv[8] := in console
i4 : bv[8] := in console
i5 : bv[8] := in console

# Current table (provided as input)
i6 : bv[8] := in console
i7 : bv[8] := in console
i8 : bv[8] := in console
i9 : bv[8] := in console

# Updated table (output)
o1 : bv[8] := out console
o2 : bv[8] := out console
o3 : bv[8] := out console
o4 : bv[8] := out console
o5 : bv[8] := out console

# ----------------------------------------------------------------------------
# HELPER FUNCTIONS
# ----------------------------------------------------------------------------
# Extract the low bit of a value
bit(x) : bv[8] := x & { 1 }:bv[8]

# Flip a 0/1 bit
bit_not(x) : bv[8] := bit(x) ^ { 1 }:bv[8]

# Convert a 0/1 bit to a full-byte mask (0x00 or 0xFF)
# This enables conditional selection without branching
to_mask(x) : bv[8] := bit(x) * { 255 }:bv[8]

# Bitwise NOT for bv[8]
bv_not(x) : bv[8] := x ^ { 255 }:bv[8]

# Select between two values using a mask
# select(0xFF, yes, no) = yes
# select(0x00, yes, no) = no
select(mask, yes, no) : bv[8] := (mask & yes) | (bv_not(mask) & no)

# Mask for each table entry:
# Returns 0xFF if learn=1 AND this is the selected entry, else 0x00
mask00(s, a, learn) : bv[8] := to_mask(bit(learn) & bit_not(s) & bit_not(a))
mask01(s, a, learn) : bv[8] := to_mask(bit(learn) & bit_not(s) & bit(a))
mask10(s, a, learn) : bv[8] := to_mask(bit(learn) & bit(s) & bit_not(a))
mask11(s, a, learn) : bv[8] := to_mask(bit(learn) & bit(s) & bit(a))

# ----------------------------------------------------------------------------
# SPECIFICATION
# ----------------------------------------------------------------------------
# BREAKDOWN:
#
#   o5[t]:bv[8] = i3[t]:bv[8] + i4[t]:bv[8]
#     Compute target = reward + q_next
#
#   o1[t]:bv[8] = select(mask00(...), target, Q00)
#     If this entry is selected: output target
#     Otherwise: output unchanged Q00
#
#   (same pattern for o2, o3, o4)
#
# The masks ensure:
# - If learn=0: all masks are 0x00, so all outputs equal inputs (no change)
# - If learn=1: exactly one mask is 0xFF, so exactly one entry becomes target

# ----------------------------------------------------------------------------
# DEMO INPUT SEQUENCE
# ----------------------------------------------------------------------------
# Three update steps, starting from an all-zeros table.
#
# Each step provides 9 inputs: s, a, r, q_next, learn, Q00, Q01, Q10, Q11
#
# Step 1: Update Q(0,1) with target = 3 + 0 = 3
#   s=0, a=1, r=3, q_next=0, learn=1
#   Table: (0, 0, 0, 0) -> (0, 3, 0, 0)
#
# Step 2: Update Q(1,0) with target = 2 + 3 = 5
#   s=1, a=0, r=2, q_next=3, learn=1
#   Table: (0, 3, 0, 0) -> (0, 3, 5, 0)
#
# Step 3: Update Q(0,0) with target = 1 + 5 = 6
#   s=0, a=0, r=1, q_next=5, learn=1
#   Table: (0, 3, 5, 0) -> (6, 3, 5, 0)
#
# NOTE: This file is a REPL transcript. After `r ...`, every following line is
# treated as input. Do not place blank lines or comments after `r ...` until
# the end; one blank line terminates execution and returns to the REPL.

r (o5[t]:bv[8] = i3[t]:bv[8] + i4[t]:bv[8]) && (o1[t]:bv[8] = select(mask00(i1[t]:bv[8],i2[t]:bv[8],i5[t]:bv[8]), o5[t]:bv[8], i6[t]:bv[8])) && (o2[t]:bv[8] = select(mask01(i1[t]:bv[8],i2[t]:bv[8],i5[t]:bv[8]), o5[t]:bv[8], i7[t]:bv[8])) && (o3[t]:bv[8] = select(mask10(i1[t]:bv[8],i2[t]:bv[8],i5[t]:bv[8]), o5[t]:bv[8], i8[t]:bv[8])) && (o4[t]:bv[8] = select(mask11(i1[t]:bv[8],i2[t]:bv[8],i5[t]:bv[8]), o5[t]:bv[8], i9[t]:bv[8]))
0
1
3
0
1
0
0
0
0
1
0
2
3
1
0
3
0
0
0
0
1
5
1
0
3
5
0

q
