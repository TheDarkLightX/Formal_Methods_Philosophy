# Q-learning style tabular update (one-step function) in Tau
#
# Goal
# Demonstrate "a lookup table + a precise update rule" in a way that is fast to execute in the Tau interpreter.
#
# Modeling choice
# This file treats the Q-table as an input (the current learned table) and produces the updated table as output.
# This keeps the spec local-in-time and avoids expensive temporal normalization.
#
# Inputs (bv[8], provided as decimal integers in 0..255)
# - i1[t]  = s       (state bit, 0/1)
# - i2[t]  = a       (action bit, 0/1)
# - i3[t]  = r       (reward, small integer)
# - i4[t]  = q_next  (a value representing Q(s', a_star), supplied by the host/agent)
# - i5[t]  = learn   (0/1). If 0, output table equals input table.
#
# - i6[t]  = Q00     (current table entry Q(0,0))
# - i7[t]  = Q01     (current table entry Q(0,1))
# - i8[t]  = Q10     (current table entry Q(1,0))
# - i9[t]  = Q11     (current table entry Q(1,1))
#
# Outputs (bv[8])
# - o1[t] = Q00' (updated)
# - o2[t] = Q01' (updated)
# - o3[t] = Q10' (updated)
# - o4[t] = Q11' (updated)
# - o5[t] = target = r + q_next
#
# Update rule (simplified but Q-learning shaped)
# target = r + q_next
# if learn = 1: update exactly one entry Q(s,a) := target, keep the others unchanged
# if learn = 0: keep all entries unchanged
#
# Note
# Bitvector arithmetic is modular. This is educational and uses small values.

set charvar off

i1 : bv[8] := in console
i2 : bv[8] := in console
i3 : bv[8] := in console
i4 : bv[8] := in console
i5 : bv[8] := in console

i6 : bv[8] := in console
i7 : bv[8] := in console
i8 : bv[8] := in console
i9 : bv[8] := in console

o1 : bv[8] := out console
o2 : bv[8] := out console
o3 : bv[8] := out console
o4 : bv[8] := out console
o5 : bv[8] := out console

# Demo (three updates), each step provides:
#   s, a, r, q_next, learn, Q00, Q01, Q10, Q11
#
# Step 1: starting from all zeros, update Q(0,1) with target = 3 + 0 = 3
# Step 2: starting from (0,3,0,0), update Q(1,0) with target = 2 + 3 = 5
# Step 3: starting from (0,3,5,0), update Q(0,0) with target = 1 + 5 = 6
#
# Helper functions (term-level)
#
# This example treats i1/i2/i5 as bits stored in bv[8]. We interpret only the low bit.
# In practice, a host system should validate and pass clean bits or one-hot flags into Tau.

bit(x) : bv[8] := x & { 1 }:bv[8]
bit_not(x) : bv[8] := bit(x) ^ { 1 }:bv[8]

# Convert a 0/1 bit into a full-byte mask:
# - to_mask(0) = 0x00
# - to_mask(1) = 0xFF
to_mask(x) : bv[8] := bit(x) * { #xFF }:bv[8]

# Bitwise NOT for bv[8] values.
bv_not(x) : bv[8] := x ^ { #xFF }:bv[8]

# Select between two bv[8] values using a 0x00/0xFF mask.
select(mask, yes, no) : bv[8] := (mask & yes) | (bv_not(mask) & no)

mask00(s, a, learn) : bv[8] := to_mask(bit(learn) & bit_not(s) & bit_not(a))
mask01(s, a, learn) : bv[8] := to_mask(bit(learn) & bit_not(s) & bit(a))
mask10(s, a, learn) : bv[8] := to_mask(bit(learn) & bit(s) & bit_not(a))
mask11(s, a, learn) : bv[8] := to_mask(bit(learn) & bit(s) & bit(a))

# Note: the `r ...` command must be a single line (it is one command in the interpreter).
r (o5[t]:bv[8] = i3[t]:bv[8] + i4[t]:bv[8]) && (o1[t]:bv[8] = select(mask00(i1[t],i2[t],i5[t]), o5[t]:bv[8], i6[t]:bv[8])) && (o2[t]:bv[8] = select(mask01(i1[t],i2[t],i5[t]), o5[t]:bv[8], i7[t]:bv[8])) && (o3[t]:bv[8] = select(mask10(i1[t],i2[t],i5[t]), o5[t]:bv[8], i8[t]:bv[8])) && (o4[t]:bv[8] = select(mask11(i1[t],i2[t],i5[t]), o5[t]:bv[8], i9[t]:bv[8]))
0
1
3
0
1
0
0
0
0
1
0
2
3
1
0
3
0
0
0
0
1
5
1
0
3
5
0

q
